{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"IUPred","text":"<p>Prediction of intrinsically disordered protein regions using IUPred2/ANCHOR2 and AIUPred methods.</p> <p>Documentation | GitHub | IUPred2A Web Server | AIUPred Web Server</p>"},{"location":"#description","title":"Description","text":"<p>Intrinsically disordered proteins (IDPs) lack a single well-defined tertiary structure under native conditions. This package provides methods for predicting disordered regions in protein sequences:</p> <ul> <li>IUPred2 - Energy-based prediction of intrinsically disordered regions</li> <li>ANCHOR2 - Prediction of disordered binding regions where unstructured   proteins interact with partners</li> <li>AIUPred - Deep learning approach combining energy estimation with   transformer networks for enhanced disorder prediction</li> </ul>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Zsuzsanna Dosztanyi (ELTE, Budapest)</li> <li>Gabor Erdos (ELTE, Budapest)</li> <li>Norbert Deutsch (ELTE, Budapest; AIUPred-binding)</li> <li>Balint Meszaros (ELTE, Budapest; IUPred2A)</li> </ul>"},{"location":"#additional-contributors","title":"Additional Contributors","text":"<ul> <li>Denes Turei (modern tooling and packaging)</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.9</li> <li>numpy &gt;= 1.20</li> <li>scipy &gt;= 1.7</li> <li>torch &gt;= 1.9 (optional, for AIUPred only)</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#using-pip-from-github","title":"Using pip (from GitHub)","text":"<pre><code># Basic installation (IUPred2/ANCHOR2 only)\npip install git+https://github.com/saezlab/iupred.git\n\n# With AIUPred support (requires PyTorch)\npip install \"iupred[aiupred] @ git+https://github.com/saezlab/iupred.git\"\n</code></pre>"},{"location":"#using-uv-recommended","title":"Using uv (recommended)","text":"<p>uv is a fast Python package manager:</p> <pre><code># Install uv if you don't have it\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Create a new project with iupred (IUPred2/ANCHOR2 only)\nuv init my-project\ncd my-project\nuv add git+https://github.com/saezlab/iupred.git\n\n# Or with AIUPred support\nuv add \"iupred[aiupred] @ git+https://github.com/saezlab/iupred.git\"\n</code></pre>"},{"location":"#development-installation","title":"Development installation","text":"<pre><code>git clone https://github.com/saezlab/iupred.git\ncd iupred\n\n# Using uv (recommended)\nuv venv\nsource .venv/bin/activate\nuv pip install -e \".[tests]\"\n\n# With AIUPred support\nuv pip install -e \".[tests,aiupred]\"\n\n# Or using pip\npython -m venv .venv\nsource .venv/bin/activate\npip install -e \".[tests]\"\n\n# With AIUPred support\npip install -e \".[tests,aiupred]\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#iupred2-bundled-data-works-out-of-the-box","title":"IUPred2 (bundled data, works out of the box)","text":"<p>IUPred2 predicts intrinsically disordered regions based on estimated pairwise interaction energies.</p> <pre><code>from iupred import iupred, anchor2\n\nsequence = \"MAEGEITTFTALTEKFNLPPGNYKKPKLLYCSNG...\"\n\n# Predict disorder using IUPred2\n# Returns tuple of (scores, glob_text)\ndisorder_scores, glob_text = iupred(sequence, mode='long')\n\n# Predict binding regions using ANCHOR2\n# Requires IUPred scores as input\nanchor_scores = anchor2(sequence, disorder_scores)\n</code></pre> <p>Available modes for <code>iupred()</code>:</p> <ul> <li><code>'short'</code> - Short disorder prediction (default), optimized for shorter   disordered segments</li> <li><code>'long'</code> - Long disorder prediction, identifies extended disordered regions</li> <li><code>'glob'</code> - Globular domain prediction, locates stable folded regions</li> </ul>"},{"location":"#aiupred-automatic-model-download","title":"AIUPred (automatic model download)","text":"<p>AIUPred uses transformer-based deep learning for enhanced disorder prediction. Model weights (~82 MB) are automatically downloaded on first use.</p> <pre><code>from iupred import aiupred_disorder, aiupred_binding\n\nsequence = \"MAEGEITTFTALTEKFNLPPGNYKKPKLLYCSNG...\"\n\n# Predict disorder using AIUPred\n# Models are downloaded automatically on first call\ndisorder_scores = aiupred_disorder(sequence)\n\n# Predict binding regions\nbinding_scores = aiupred_binding(sequence)\n</code></pre> <p>Models are cached in <code>~/.cache/iupred/</code> and only downloaded once.</p> <p>Data management:</p> <pre><code>from iupred import ensure_aiupred_data, clear_aiupred_cache\n\n# Pre-download models (optional, useful for offline use)\nensure_aiupred_data()\n\n# Clear cached models to free disk space or force re-download\nclear_aiupred_cache()\n</code></pre> <p>Options:</p> <ul> <li><code>force_cpu=True</code> - Force CPU-only mode (default: use GPU if available)</li> <li><code>gpu_num=0</code> - GPU index to use (default: 0)</li> </ul>"},{"location":"#performance-aiupred","title":"Performance (AIUPred)","text":"Hardware Task Speed GPU (1080 Ti 12GB) Single protein ~3 seconds GPU (1080 Ti 12GB) Human proteome ~100 proteins/second CPU (Xeon E3-1270) Single protein ~1.7 seconds CPU (Xeon E3-1270) Human proteome ~3.5 proteins/second <p>Memory requirements: 2GB VRAM handles ~3,000 residues; 12GB handles ~16,000.</p>"},{"location":"#command-line-interface","title":"Command-Line Interface","text":"<p>The package provides a CLI for running predictions from the terminal:</p> <pre><code># IUPred2 prediction (fast, no downloads required)\niupred iupred2 -i sequences.fasta -o results.txt -m long\n\n# IUPred2 with ANCHOR2 binding prediction\niupred iupred2 -i sequences.fasta -a\n\n# AIUPred prediction (models downloaded on first use)\niupred aiupred -i sequences.fasta -o results.txt\n\n# AIUPred with binding prediction, CPU-only mode\niupred aiupred -i sequences.fasta -b --force-cpu\n\n# AIUPred low-memory mode for long sequences\niupred aiupred -i sequences.fasta --low-memory --chunk-size 1000\n</code></pre>"},{"location":"#references","title":"References","text":"<p>If you use IUPred2/ANCHOR2, please cite:</p> <p>Meszaros B, Erdos G, Dosztanyi Z. IUPred2A: context-dependent prediction of protein disorder as a function of redox state and protein binding. Nucleic Acids Res. 2018;46(W1):W329-W337. https://doi.org/10.1093/nar/gky384</p> BibTeX <pre><code>@article{meszaros2018iupred2a,\n    author = {M\u00e9sz\u00e1ros, B\u00e1lint and Erd\u0151s, G\u00e1bor and Doszt\u00e1nyi, Zsuzsanna},\n    title = {{IUPred2A}: context-dependent prediction of protein disorder\n             as a function of redox state and protein binding},\n    journal = {Nucleic Acids Research},\n    volume = {46},\n    number = {W1},\n    pages = {W329-W337},\n    year = {2018},\n    doi = {10.1093/nar/gky384}\n}\n</code></pre> <p>If you use AIUPred, please cite:</p> <p>Erdos G, Dosztanyi Z. AIUPred: combining energy estimation with deep learning for the enhanced prediction of protein disorder. Nucleic Acids Res. 2024;52(W1):W176-W181. https://doi.org/10.1093/nar/gkae385</p> BibTeX <pre><code>@article{erdos2024aiupred,\n    author = {Erd\u0151s, G\u00e1bor and Doszt\u00e1nyi, Zsuzsanna},\n    title = {{AIUPred}: combining energy estimation with deep learning\n             for the enhanced prediction of protein disorder},\n    journal = {Nucleic Acids Research},\n    volume = {52},\n    number = {W1},\n    pages = {W176-W181},\n    year = {2024},\n    doi = {10.1093/nar/gkae385}\n}\n</code></pre> <p>If you use AIUPred-binding, please cite:</p> <p>Erdos G, Deutsch A, Dosztanyi Z. Identification of disordered binding regions using energy embedding. J Mol Biol. 2025;437(15):169071. https://doi.org/10.1016/j.jmb.2025.169071</p> BibTeX <pre><code>@article{erdos2025aiupred_binding,\n    author = {Erd\u0151s, G\u00e1bor and Deutsch, Norbert and Doszt\u00e1nyi, Zsuzsanna},\n    title = {{AIUPred} -- Binding: Energy Embedding to Identify\n             Disordered Binding Regions},\n    journal = {Journal of Molecular Biology},\n    volume = {437},\n    number = {15},\n    pages = {169071},\n    year = {2025},\n    doi = {10.1016/j.jmb.2025.169071}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This software is distributed under the CC-BY-NC-ND-4.0 license. Commercial use and derivative works are not permitted without explicit permission from the authors.</p> <p>For commercial licensing inquiries, please contact: Zsuzsanna Dosztanyi zsuzsanna.dosztanyi@ttk.elte.hu</p>"},{"location":"#development","title":"Development","text":""},{"location":"#running-tests","title":"Running tests","text":"<pre><code># Install test dependencies\nuv pip install -e \".[tests]\"\n\n# Run tests\npytest\n\n# Run tests with coverage\npytest --cov=iupred\n</code></pre>"},{"location":"#linting-and-formatting","title":"Linting and formatting","text":"<p>The project uses ruff for linting and formatting:</p> <pre><code># Check for issues\nruff check .\n\n# Auto-fix issues\nruff check --fix .\n\n# Format code\nruff format .\n</code></pre>"},{"location":"#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>Pre-commit hooks are configured for automated checks:</p> <pre><code># Install pre-commit hooks\nuv pip install -e \".[dev]\"\npre-commit install\n\n# Run hooks manually on all files\npre-commit run --all-files\n</code></pre>"},{"location":"#building-documentation","title":"Building documentation","text":"<p>Documentation is built with MkDocs:</p> <pre><code># Install docs dependencies\nuv pip install -e \".[docs]\"\n\n# Serve docs locally\nmkdocs serve\n\n# Build static docs\nmkdocs build\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p>For questions and support, please contact: Zsuzsanna Dosztanyi zsuzsanna.dosztanyi@ttk.elte.hu</p> <p>Feature requests and bug reports can be submitted via GitHub Issues.</p>"},{"location":"reference/","title":"API Reference","text":"<p>This page documents the public API of the <code>iupred</code> package.</p>"},{"location":"reference/#iupred2-functions","title":"IUPred2 Functions","text":"<p>Energy-based prediction of intrinsically disordered regions.</p>"},{"location":"reference/#iupred.iupred","title":"<code>iupred.iupred(seq, mode='short', folder=None)</code>","text":"<p>Predict intrinsically disordered regions using IUPred2.</p> <p>IUPred2 estimates the energy required to form stabilizing contacts for each residue. Residues with high energy (unable to form stable contacts) are predicted as disordered.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <p>Amino acid sequence as a string. Standard one-letter amino acid codes are expected. Unknown residues are handled gracefully.</p> required <code>mode</code> <p>Prediction mode. Options:</p> <ul> <li><code>'short'</code>: Optimized for short disordered segments (default)</li> <li><code>'long'</code>: Identifies extended disordered regions</li> <li><code>'glob'</code>: Globular domain prediction with domain annotations</li> </ul> <code>'short'</code> <code>folder</code> <p>Path to data directory containing energy matrices and histograms. Defaults to the bundled data shipped with the package.</p> <code>None</code> <p>Returns:</p> Type Description <p>A tuple of <code>(iupred_scores, glob_text)</code> where:</p> <ul> <li><code>iupred_scores</code>: List of disorder propensity values (0.0-1.0) for each residue. Values above 0.5 indicate disorder.</li> </ul> <ul> <li><code>glob_text</code>: Domain annotation string (non-empty only for <code>mode='glob'</code>). Contains identified globular domains and their boundaries.</li> </ul> Example <p>from iupred import iupred scores, glob = iupred('MEEPQSDPSVEPPLSQETFSDLWK', mode='long') len(scores) 24 scores[0] &gt; 0.5  # First residue is disordered True</p> References <p>Meszaros B, Erdos G, Dosztanyi Z. IUPred2A: context-dependent prediction of protein disorder. Nucleic Acids Res. 2018.</p>"},{"location":"reference/#iupred.anchor2","title":"<code>iupred.anchor2(seq, iupred_scores, folder=None)</code>","text":"<p>Predict disordered binding regions using ANCHOR2.</p> <p>ANCHOR2 identifies disordered regions that are likely to undergo disorder-to-order transition upon binding to a partner protein. These regions are intrinsically disordered but can fold when interacting with globular protein partners.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <p>Amino acid sequence as a string. Must match the sequence used to generate <code>iupred_scores</code>.</p> required <code>iupred_scores</code> <p>IUPred disorder scores for the sequence, obtained from the :func:<code>iupred</code> function. The scores are used to identify regions that are both disordered and likely to bind.</p> required <code>folder</code> <p>Path to data directory containing ANCHOR2 matrices. Defaults to the bundled data shipped with the package.</p> <code>None</code> <p>Returns:</p> Type Description <p>List of ANCHOR2 binding propensity scores (0.0-1.0) for each</p> <p>residue. Values above 0.5 indicate predicted binding regions.</p> Example <p>from iupred import iupred, anchor2 sequence = 'MEEPQSDPSVEPPLSQETFSDLWK' disorder_scores, _ = iupred(sequence) binding_scores = anchor2(sequence, disorder_scores) len(binding_scores) 24</p> References <p>Meszaros B, Erdos G, Dosztanyi Z. IUPred2A: context-dependent prediction of protein disorder. Nucleic Acids Res. 2018.</p>"},{"location":"reference/#aiupred-functions","title":"AIUPred Functions","text":"<p>Transformer-based deep learning prediction of disordered regions.</p>"},{"location":"reference/#simple-api","title":"Simple API","text":"<p>For single sequence predictions, use these convenience functions:</p>"},{"location":"reference/#iupred.aiupred_disorder","title":"<code>iupred.aiupred_disorder(sequence, force_cpu=False, gpu_num=0)</code>","text":"<p>Predict intrinsically disordered regions using AIUPred.</p> <p>AIUPred combines energy estimation with deep learning (transformer networks) for enhanced disorder prediction. It generally provides more accurate predictions than IUPred2, especially for complex cases.</p> Note <p>Model weights (~82 MB) are automatically downloaded on first use and cached in <code>~/.cache/iupred/</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <p>Amino acid sequence as a string. Standard one-letter amino acid codes are expected. Unknown residues (e.g., 'X') are handled gracefully.</p> required <code>force_cpu</code> <p>If <code>True</code>, force CPU-only mode even if a GPU is available. Useful for debugging or when GPU memory is limited.</p> <code>False</code> <code>gpu_num</code> <p>Index of the GPU to use when multiple GPUs are available. Default is 0 (first GPU).</p> <code>0</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Disorder propensity scores (0.0-1.0) for each</p> <p>residue. Values above 0.5 indicate predicted disorder. Results</p> <p>are smoothed using a Savitzky-Golay filter.</p> Example <p>from iupred import aiupred_disorder scores = aiupred_disorder('MEEPQSDPSVEPPLSQETFSDLWK') len(scores) 24 scores[0] &gt; 0.5  # First residue is disordered True</p> References <p>Erdos G, Dosztanyi Z. AIUPred: combining energy estimation with deep learning for the enhanced prediction of protein disorder. Nucleic Acids Res. 2024.</p>"},{"location":"reference/#iupred.aiupred_binding","title":"<code>iupred.aiupred_binding(sequence, force_cpu=False, gpu_num=0)</code>","text":"<p>Predict disordered binding regions using AIUPred.</p> <p>AIUPred-binding identifies disordered regions that are likely to undergo disorder-to-order transition upon binding to partner proteins. It uses energy embedding from a transformer network to predict binding propensity.</p> Note <p>Model weights (~82 MB) are automatically downloaded on first use and cached in <code>~/.cache/iupred/</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <p>Amino acid sequence as a string. Standard one-letter amino acid codes are expected. Unknown residues (e.g., 'X') are handled gracefully.</p> required <code>force_cpu</code> <p>If <code>True</code>, force CPU-only mode even if a GPU is available. Useful for debugging or when GPU memory is limited.</p> <code>False</code> <code>gpu_num</code> <p>Index of the GPU to use when multiple GPUs are available. Default is 0 (first GPU).</p> <code>0</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Binding propensity scores (0.0-1.0) for each</p> <p>residue. Values above 0.5 indicate predicted binding regions.</p> <p>Results are smoothed using a Savitzky-Golay filter.</p> Example <p>from iupred import aiupred_binding scores = aiupred_binding('MEEPQSDPSVEPPLSQETFSDLWK') len(scores) 24</p> References <p>Erdos G, Deutsch A, Dosztanyi Z. Identification of disordered binding regions using energy embedding. J Mol Biol. 2025.</p>"},{"location":"reference/#batch-processing-api","title":"Batch Processing API","text":"<p>For efficient processing of multiple sequences, initialize models once and reuse them:</p>"},{"location":"reference/#iupred.init_aiupred_models","title":"<code>iupred.init_aiupred_models(prediction_type, force_cpu=False, gpu_num=0)</code>","text":"<p>Initialize networks and device to run on.</p> <p>Parameters:</p> Name Type Description Default <code>prediction_type</code> <p>Type of prediction ('disorder' or 'binding').</p> required <code>force_cpu</code> <p>Force the method to run on CPU only mode.</p> <code>False</code> <code>gpu_num</code> <p>Index of the GPU to use, default=0.</p> <code>0</code> <p>Returns:</p> Type Description <p>Tuple of (embedding_model, regression_model, device).</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If PyTorch is not installed.</p>"},{"location":"reference/#iupred.predict_aiupred_disorder","title":"<code>iupred.predict_aiupred_disorder(sequence, energy_model, regression_model, device, smoothing=None)</code>","text":"<p>Predict disorder propensity using pre-initialized models.</p> <p>This function is useful for batch processing multiple sequences efficiently, as the models are initialized once and reused.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <p>Amino acid sequence as a string.</p> required <code>energy_model</code> <p>Pre-initialized transformer model from :func:<code>init_aiupred_models</code>.</p> required <code>regression_model</code> <p>Pre-initialized regression model from :func:<code>init_aiupred_models</code>.</p> required <code>device</code> <p>PyTorch device (CPU or CUDA) from :func:<code>init_aiupred_models</code>.</p> required <code>smoothing</code> <p>If <code>True</code>, apply Savitzky-Golay filter to smooth the output. Default is <code>None</code> (no smoothing).</p> <code>None</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Disorder propensity scores (0.0-1.0) for each residue.</p> Example <p>from iupred import init_aiupred_models, predict_aiupred_disorder model, reg, device = init_aiupred_models('disorder') for seq in sequences: ...     scores = predict_aiupred_disorder(seq, model, reg, device, smoothing=True)</p>"},{"location":"reference/#iupred.predict_aiupred_binding","title":"<code>iupred.predict_aiupred_binding(sequence, embedding_model, decoder_model, device, smoothing=None, energy_only=False, binding=False)</code>","text":"<p>Predict binding propensity using pre-initialized models.</p> <p>This function is useful for batch processing multiple sequences efficiently, as the models are initialized once and reused.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <p>Amino acid sequence as a string.</p> required <code>embedding_model</code> <p>Pre-initialized embedding model from :func:<code>init_aiupred_models</code> with <code>prediction_type='binding'</code>.</p> required <code>decoder_model</code> <p>Pre-initialized decoder model from :func:<code>init_aiupred_models</code>.</p> required <code>device</code> <p>PyTorch device (CPU or CUDA) from :func:<code>init_aiupred_models</code>.</p> required <code>smoothing</code> <p>If <code>True</code>, apply Savitzky-Golay filter to smooth the output. Default is <code>None</code> (no smoothing).</p> <code>None</code> <code>energy_only</code> <p>If <code>True</code>, return raw energy embeddings instead of binding predictions. Default is <code>False</code>.</p> <code>False</code> <code>binding</code> <p>If <code>True</code>, apply binding transformation to scores. Should be <code>True</code> for final binding predictions.</p> <code>False</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Binding propensity scores (0.0-1.0) for each residue</p> <p>when <code>binding=True</code>, or raw predictions otherwise.</p> Example <p>from iupred import init_aiupred_models, predict_aiupred_binding model, reg, device = init_aiupred_models('binding') scores = predict_aiupred_binding(seq, model, reg, device, binding=True, smoothing=True)</p>"},{"location":"reference/#low-memory-api","title":"Low-Memory API","text":"<p>For very long sequences or memory-constrained systems, use chunked processing:</p>"},{"location":"reference/#iupred.low_memory_aiupred_disorder","title":"<code>iupred.low_memory_aiupred_disorder(sequence, embedding_model, decoder_model, device, smoothing=None, chunk_len=1000)</code>","text":"<p>Predict disorder using chunked processing for long sequences.</p> <p>This function processes sequences in overlapping chunks to reduce memory usage. Useful for very long sequences (&gt;3000 residues) or systems with limited GPU memory.</p> Note <p>Results may differ slightly from the standard prediction due to chunk boundary effects.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <p>Amino acid sequence as a string.</p> required <code>embedding_model</code> <p>Pre-initialized transformer model from :func:<code>init_aiupred_models</code>.</p> required <code>decoder_model</code> <p>Pre-initialized regression model from :func:<code>init_aiupred_models</code>.</p> required <code>device</code> <p>PyTorch device (CPU or CUDA) from :func:<code>init_aiupred_models</code>.</p> required <code>smoothing</code> <p>If <code>True</code>, apply Savitzky-Golay filter to smooth the output. Default is <code>None</code> (no smoothing).</p> <code>None</code> <code>chunk_len</code> <p>Length of each processing chunk. Default is 1000. Must be greater than 200 (the overlap size is 100).</p> <code>1000</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Disorder propensity scores (0.0-1.0) for each residue.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If chunk_len is less than or equal to 200.</p> Example <p>from iupred import init_aiupred_models, low_memory_aiupred_disorder model, reg, device = init_aiupred_models('disorder') scores = low_memory_aiupred_disorder(long_sequence, model, reg, device, smoothing=True)</p>"},{"location":"reference/#iupred.low_memory_aiupred_binding","title":"<code>iupred.low_memory_aiupred_binding(sequence, embedding_model, decoder_model, device, smoothing=None, chunk_len=1000)</code>","text":"<p>Predict binding using chunked processing for long sequences.</p> <p>This function processes sequences in overlapping chunks to reduce memory usage. Useful for very long sequences (&gt;3000 residues) or systems with limited GPU memory.</p> Note <p>Results may differ slightly from the standard prediction due to chunk boundary effects.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <p>Amino acid sequence as a string.</p> required <code>embedding_model</code> <p>Pre-initialized embedding model from :func:<code>init_aiupred_models</code> with <code>prediction_type='binding'</code>.</p> required <code>decoder_model</code> <p>Pre-initialized decoder model from :func:<code>init_aiupred_models</code>.</p> required <code>device</code> <p>PyTorch device (CPU or CUDA) from :func:<code>init_aiupred_models</code>.</p> required <code>smoothing</code> <p>If <code>True</code>, apply Savitzky-Golay filter to smooth the output. Default is <code>True</code>.</p> <code>None</code> <code>chunk_len</code> <p>Length of each processing chunk. Default is 1000. Must be greater than 200 (the overlap size is 100).</p> <code>1000</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Binding propensity scores (0.0-1.0) for each residue.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If chunk_len is less than or equal to 200.</p> Example <p>from iupred import init_aiupred_models, low_memory_aiupred_binding model, reg, device = init_aiupred_models('binding') scores = low_memory_aiupred_binding(long_sequence, model, reg, device, smoothing=True)</p>"},{"location":"reference/#data-management","title":"Data Management","text":"<p>Functions for managing AIUPred model weights.</p>"},{"location":"reference/#iupred.ensure_aiupred_data","title":"<code>iupred.ensure_aiupred_data()</code>","text":"<p>Ensure AIUPred model weights are available, downloading if necessary.</p> <p>This function checks if all required AIUPred model files are present in the cache directory. If not, it downloads and extracts them from the remote server (~82 MB download).</p> <p>The data is cached in a platform-specific location:</p> <ul> <li>Linux: <code>~/.cache/iupred/</code></li> <li>macOS: <code>~/Library/Caches/iupred/</code></li> <li>Windows: <code>%LOCALAPPDATA%\\\\iupred\\\\Cache</code></li> </ul> Note <p>This function is called automatically by :func:<code>aiupred_disorder</code> and :func:<code>aiupred_binding</code>. You only need to call it explicitly if you want to pre-download the models (e.g., for offline use).</p> <p>Returns:</p> Type Description <p>pathlib.Path: Path to the cache directory containing the model files.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download or extraction fails.</p> Example <p>from iupred import ensure_aiupred_data cache_dir = ensure_aiupred_data() print(cache_dir) /home/user/.cache/iupred</p>"},{"location":"reference/#iupred.clear_aiupred_cache","title":"<code>iupred.clear_aiupred_cache()</code>","text":"<p>Remove all cached AIUPred model files.</p> <p>Deletes all AIUPred model weights from the cache directory, freeing approximately 82 MB of disk space. The models will be re-downloaded automatically on the next call to :func:<code>aiupred_disorder</code> or :func:<code>aiupred_binding</code>.</p> <p>This can be useful to:</p> <ul> <li>Free up disk space</li> <li>Force re-download of potentially corrupted files</li> <li>Update to newer model versions (when available)</li> </ul> Example <p>from iupred import clear_aiupred_cache clear_aiupred_cache()</p>"},{"location":"reference/#command-line-interface","title":"Command-Line Interface","text":"<p>The package provides a command-line interface for running predictions from the terminal:</p> <pre><code># IUPred2 prediction\niupred iupred2 -i sequences.fasta -o results.txt -m long -a\n\n# AIUPred prediction\niupred aiupred -i sequences.fasta -o results.txt -b --force-cpu\n</code></pre>"},{"location":"reference/#iupred2-cli-options","title":"IUPred2 CLI Options","text":"Option Description <code>-i, --input-file</code> Input FASTA file (required) <code>-o, --output-file</code> Output file (default: stdout) <code>-m, --mode</code> Prediction mode: short, long, or glob (default: long) <code>-a, --anchor</code> Also predict binding regions with ANCHOR2 <code>-v, --verbose</code> Enable verbose output"},{"location":"reference/#aiupred-cli-options","title":"AIUPred CLI Options","text":"Option Description <code>-i, --input-file</code> Input FASTA file (required) <code>-o, --output-file</code> Output file (default: stdout) <code>-b, --binding</code> Also predict binding regions <code>-g, --gpu</code> GPU index to use (default: 0) <code>--force-cpu</code> Force CPU-only mode <code>--low-memory</code> Use low-memory mode for long sequences <code>--chunk-size</code> Chunk size for low-memory mode (default: 1000) <code>-v, --verbose</code> Enable verbose output"},{"location":"tutorials/batch_prediction/","title":"Batch Prediction for Multiple Sequences","text":"<p>This tutorial demonstrates how to efficiently predict disorder for multiple protein sequences by initializing models once and reusing them.</p>"},{"location":"tutorials/batch_prediction/#why-batch-processing","title":"Why Batch Processing?","text":"<p>When processing multiple sequences, the simple approach of calling <code>aiupred_disorder()</code> for each sequence works but is inefficient because:</p> <ol> <li>Models are loaded from disk for each sequence</li> <li>Models are transferred to GPU for each sequence</li> </ol> <p>For batch processing, we initialize models once and reuse them, which is much faster for large datasets.</p>"},{"location":"tutorials/batch_prediction/#setup","title":"Setup","text":"<pre><code>from iupred import (\n    iupred,\n    anchor2,\n    init_aiupred_models,\n    predict_aiupred_disorder,\n    predict_aiupred_binding,\n)\n</code></pre>"},{"location":"tutorials/batch_prediction/#example-sequences","title":"Example Sequences","text":"<p>Let's create a small dataset of protein sequences to analyze:</p> <pre><code># Example sequences (various human proteins with known disordered regions)\nsequences = {\n    'p53_TAD': 'MEEPQSDPSVEPPLSQETFSDLWKLLPENNVLSPLPSQAMDDLMLSPDDIEQWFTEDPGP',\n    'p53_DBD': 'SVTCTYSPALNKMFCQLAKTCPVQLWVDSTPPPGTRVRAMAIYKQSQHMTEVVRRCPHHE',\n    'alpha_synuclein': 'MDVFMKGLSKAKEGVVAAAEKTKQGVAEAAGKTKEGVLYVGSKTKEGVVHGVATVAEKTK',\n    'ubiquitin': 'MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYN',\n}\n\nprint(f\"Number of sequences: {len(sequences)}\")\nfor name, seq in sequences.items():\n    print(f\"  {name}: {len(seq)} residues\")\n</code></pre>"},{"location":"tutorials/batch_prediction/#iupred2-batch-processing","title":"IUPred2 Batch Processing","text":"<p>IUPred2 is already fast since it doesn't require loading neural network models. Simply iterate over sequences:</p> <pre><code>iupred2_results = {}\n\nfor name, sequence in sequences.items():\n    disorder_scores, _ = iupred(sequence, mode='long')\n    binding_scores = anchor2(sequence, disorder_scores)\n\n    iupred2_results[name] = {\n        'disorder': disorder_scores,\n        'binding': binding_scores,\n    }\n\n    mean_disorder = sum(disorder_scores) / len(disorder_scores)\n    print(f\"{name}: mean disorder = {mean_disorder:.3f}\")\n</code></pre>"},{"location":"tutorials/batch_prediction/#aiupred-batch-processing","title":"AIUPred Batch Processing","text":"<p>For AIUPred, we initialize the models once and reuse them for all sequences. This is the recommended approach for processing multiple sequences.</p>"},{"location":"tutorials/batch_prediction/#initialize-models","title":"Initialize Models","text":"<pre><code># Initialize disorder prediction models once\ndisorder_model, disorder_reg, device = init_aiupred_models('disorder', force_cpu=True)\nprint(f\"Models loaded on device: {device}\")\n\n# Initialize binding prediction models once\nbinding_model, binding_reg, _ = init_aiupred_models('binding', force_cpu=True)\nprint(\"Binding models loaded\")\n</code></pre>"},{"location":"tutorials/batch_prediction/#process-sequences","title":"Process Sequences","text":"<pre><code># Process all sequences using the pre-initialized models\naiupred_results = {}\n\nfor name, sequence in sequences.items():\n    # Predict disorder\n    disorder_scores = predict_aiupred_disorder(\n        sequence, disorder_model, disorder_reg, device, smoothing=True\n    )\n\n    # Predict binding\n    binding_scores = predict_aiupred_binding(\n        sequence, binding_model, binding_reg, device, binding=True, smoothing=True\n    )\n\n    aiupred_results[name] = {\n        'disorder': disorder_scores,\n        'binding': binding_scores,\n    }\n\n    mean_disorder = float(disorder_scores.mean())\n    print(f\"{name}: mean disorder = {mean_disorder:.3f}\")\n</code></pre>"},{"location":"tutorials/batch_prediction/#comparing-results","title":"Comparing Results","text":"<pre><code>import numpy as np\n\nprint(\"Summary of mean disorder scores:\")\nprint(f\"{'Protein':&lt;20} {'IUPred2':&gt;10} {'AIUPred':&gt;10}\")\nprint(\"-\" * 42)\n\nfor name in sequences:\n    iupred2_mean = np.mean(iupred2_results[name]['disorder'])\n    aiupred_mean = np.mean(aiupred_results[name]['disorder'])\n    print(f\"{name:&lt;20} {iupred2_mean:&gt;10.3f} {aiupred_mean:&gt;10.3f}\")\n</code></pre>"},{"location":"tutorials/batch_prediction/#reading-from-fasta-files","title":"Reading from FASTA Files","text":"<p>For larger datasets, you'll typically read sequences from a FASTA file:</p> <pre><code>def read_fasta(filepath):\n    \"\"\"Read sequences from a FASTA file.\"\"\"\n    sequences = {}\n    header = None\n\n    with open(filepath) as f:\n        for line in f:\n            line = line.strip()\n            if line.startswith('&gt;'):\n                header = line[1:].split()[0]  # Take first word as ID\n                sequences[header] = ''\n            elif header and line:\n                sequences[header] += line.upper()\n\n    return sequences\n\n# Example usage:\n# sequences = read_fasta('proteins.fasta')\n# for name, seq in sequences.items():\n#     scores = predict_aiupred_disorder(seq, disorder_model, disorder_reg, device, smoothing=True)\n#     print(f\"{name}: mean = {scores.mean():.3f}\")\n</code></pre>"},{"location":"tutorials/batch_prediction/#performance-tips","title":"Performance Tips","text":"<ol> <li>Initialize models once - Don't call <code>aiupred_disorder()</code> in a loop; use <code>init_aiupred_models()</code> + <code>predict_aiupred_disorder()</code></li> <li>Use GPU when available - Set <code>force_cpu=False</code> for significant speedup</li> <li>Process in batches - Don't load all sequences into memory at once for very large datasets</li> </ol>"},{"location":"tutorials/low_memory/","title":"Low-Memory Prediction for Long Sequences","text":"<p>This tutorial demonstrates how to predict disorder for very long protein sequences using memory-efficient chunked processing.</p>"},{"location":"tutorials/low_memory/#when-to-use-low-memory-mode","title":"When to Use Low-Memory Mode","text":"<p>The standard AIUPred prediction requires memory proportional to sequence length. Approximate memory requirements:</p> GPU VRAM Max Sequence Length 2 GB ~3,000 residues 6 GB ~8,000 residues 12 GB ~16,000 residues <p>For sequences longer than your memory allows, or when running on CPU with limited RAM, use the low-memory functions which process sequences in chunks.</p>"},{"location":"tutorials/low_memory/#setup","title":"Setup","text":"<pre><code>from iupred import (\n    init_aiupred_models,\n    predict_aiupred_disorder,\n    low_memory_aiupred_disorder,\n    low_memory_aiupred_binding,\n)\n</code></pre>"},{"location":"tutorials/low_memory/#example-long-protein-sequence","title":"Example: Long Protein Sequence","text":"<p>For demonstration, we'll create a long sequence by repeating p53:</p> <pre><code># Human p53 sequence\np53_sequence = (\n    \"MEEPQSDPSVEPPLSQETFSDLWKLLPENNVLSPLPSQAMDDLMLSPDDIEQWFTEDPGP\"\n    \"DEAPRMPEAAPPVAPAPAAPTPAAPAPAPSWPLSSSVPSQKTYQGSYGFRLGFLHSGTAK\"\n    \"SVTCTYSPALNKMFCQLAKTCPVQLWVDSTPPPGTRVRAMAIYKQSQHMTEVVRRCPHHE\"\n    \"RCSDSDGLAPPQHLIRVEGNLRVEYLDDRNTFRHSVVVPYEPPEVGSDCTTIHYNYMCNS\"\n    \"SCMGGMNRRPILTIITLEDSSGNLLGRNSFEVRVCACPGRDRRTEEENLRKKGEPHHELP\"\n    \"PGSTKRALPNNTSSSPQPKKKPLDGEYFTLQIRGRERFEMFRELNEALELKDAQAGKEPG\"\n    \"GSRAHSSHLKSKKGQSTSRHKKLMFKTEGPDSD\"\n)\n\n# Create a ~4000 residue sequence\nlong_sequence = p53_sequence * 10\nprint(f\"Long sequence length: {len(long_sequence)} residues\")\n</code></pre>"},{"location":"tutorials/low_memory/#initialize-models","title":"Initialize Models","text":"<pre><code># Initialize disorder model\ndisorder_model, disorder_reg, device = init_aiupred_models('disorder', force_cpu=True)\nprint(f\"Models loaded on device: {device}\")\n</code></pre>"},{"location":"tutorials/low_memory/#standard-vs-low-memory-prediction","title":"Standard vs Low-Memory Prediction","text":""},{"location":"tutorials/low_memory/#standard-prediction","title":"Standard Prediction","text":"<pre><code>import time\n\n# Standard prediction (may fail for very long sequences)\nprint(\"Running standard prediction...\")\nstart = time.time()\ntry:\n    standard_scores = predict_aiupred_disorder(\n        long_sequence, disorder_model, disorder_reg, device, smoothing=True\n    )\n    standard_time = time.time() - start\n    print(f\"Standard prediction completed in {standard_time:.2f}s\")\nexcept RuntimeError as e:\n    print(f\"Standard prediction failed (likely out of memory): {e}\")\n    standard_scores = None\n</code></pre>"},{"location":"tutorials/low_memory/#low-memory-prediction","title":"Low-Memory Prediction","text":"<pre><code># Low-memory prediction with chunking\nprint(\"Running low-memory prediction...\")\nstart = time.time()\nlow_mem_scores = low_memory_aiupred_disorder(\n    long_sequence,\n    disorder_model,\n    disorder_reg,\n    device,\n    smoothing=True,\n    chunk_len=1000  # Process 1000 residues at a time\n)\nlow_mem_time = time.time() - start\nprint(f\"Low-memory prediction completed in {low_mem_time:.2f}s\")\n</code></pre>"},{"location":"tutorials/low_memory/#low-memory-binding-prediction","title":"Low-Memory Binding Prediction","text":"<pre><code># Initialize binding model\nbinding_model, binding_reg, _ = init_aiupred_models('binding', force_cpu=True)\n\n# Predict binding with low-memory mode\nprint(\"Running low-memory binding prediction...\")\nstart = time.time()\nbinding_scores = low_memory_aiupred_binding(\n    long_sequence,\n    binding_model,\n    binding_reg,\n    device,\n    smoothing=True,\n    chunk_len=1000\n)\nbinding_time = time.time() - start\nprint(f\"Binding prediction completed in {binding_time:.2f}s\")\n</code></pre>"},{"location":"tutorials/low_memory/#adjusting-chunk-size","title":"Adjusting Chunk Size","text":"<p>The <code>chunk_len</code> parameter controls the trade-off between memory usage and accuracy:</p> <ul> <li>Larger chunks (e.g., 2000): Faster, more accurate, but more memory</li> <li>Smaller chunks (e.g., 500): Slower, slightly less accurate, but less memory</li> </ul> <p>The minimum chunk size is 201 (due to 100-residue overlap).</p> <pre><code># Compare different chunk sizes\nchunk_sizes = [500, 1000, 2000]\n\nfor chunk_size in chunk_sizes:\n    start = time.time()\n    scores = low_memory_aiupred_disorder(\n        long_sequence,\n        disorder_model,\n        disorder_reg,\n        device,\n        smoothing=True,\n        chunk_len=chunk_size\n    )\n    elapsed = time.time() - start\n    print(f\"Chunk size {chunk_size}: {elapsed:.2f}s\")\n</code></pre>"},{"location":"tutorials/low_memory/#important-notes","title":"Important Notes","text":"<p>Results May Differ Slightly</p> <p>The low-memory approach may produce slightly different results at chunk boundaries due to edge effects, but overall predictions should be very similar.</p>"},{"location":"tutorials/low_memory/#tips-for-very-long-sequences","title":"Tips for Very Long Sequences","text":"<ol> <li>Start with a large chunk size and decrease if you run out of memory</li> <li>Use GPU if available - set <code>force_cpu=False</code></li> <li>Process sequences in batches - don't load all sequences into memory at once</li> <li>Consider using IUPred2 first - it's much faster and doesn't require GPU</li> </ol>"},{"location":"tutorials/single_sequence/","title":"Single Sequence Prediction","text":"<p>This tutorial demonstrates how to predict intrinsically disordered regions for a single protein sequence using both IUPred2 and AIUPred methods.</p>"},{"location":"tutorials/single_sequence/#setup","title":"Setup","text":"<p>First, import the necessary functions from the <code>iupred</code> package:</p> <pre><code>from iupred import iupred, anchor2, aiupred_disorder, aiupred_binding\n</code></pre>"},{"location":"tutorials/single_sequence/#example-sequence","title":"Example Sequence","text":"<p>We'll use the human p53 tumor suppressor protein as our example. p53 has well-characterized disordered regions at the N-terminus and C-terminus, with a structured DNA-binding domain in the middle.</p> <pre><code># Human p53 protein sequence (UniProt P04637)\np53_sequence = (\n    \"MEEPQSDPSVEPPLSQETFSDLWKLLPENNVLSPLPSQAMDDLMLSPDDIEQWFTEDPGP\"\n    \"DEAPRMPEAAPPVAPAPAAPTPAAPAPAPSWPLSSSVPSQKTYQGSYGFRLGFLHSGTAK\"\n    \"SVTCTYSPALNKMFCQLAKTCPVQLWVDSTPPPGTRVRAMAIYKQSQHMTEVVRRCPHHE\"\n    \"RCSDSDGLAPPQHLIRVEGNLRVEYLDDRNTFRHSVVVPYEPPEVGSDCTTIHYNYMCNS\"\n    \"SCMGGMNRRPILTIITLEDSSGNLLGRNSFEVRVCACPGRDRRTEEENLRKKGEPHHELP\"\n    \"PGSTKRALPNNTSSSPQPKKKPLDGEYFTLQIRGRERFEMFRELNEALELKDAQAGKEPG\"\n    \"GSRAHSSHLKSKKGQSTSRHKKLMFKTEGPDSD\"\n)\n\nprint(f\"Sequence length: {len(p53_sequence)} residues\")\n</code></pre>"},{"location":"tutorials/single_sequence/#iupred2-prediction","title":"IUPred2 Prediction","text":"<p>IUPred2 uses energy-based estimation to predict disordered regions. It's fast and works without any additional downloads.</p> <pre><code># Predict disorder using IUPred2 (long mode)\ndisorder_scores, glob_text = iupred(p53_sequence, mode='long')\n\nprint(\"IUPred2 scores for first 10 residues:\")\nfor i, (aa, score) in enumerate(zip(p53_sequence[:10], disorder_scores[:10])):\n    print(f\"  {i+1:3d} {aa}: {score:.3f}\")\n</code></pre>"},{"location":"tutorials/single_sequence/#anchor2-binding-prediction","title":"ANCHOR2 Binding Prediction","text":"<p>ANCHOR2 predicts disordered binding regions - regions that are disordered but can fold upon binding to partner proteins.</p> <pre><code># Predict binding regions using ANCHOR2\n# Note: ANCHOR2 requires IUPred scores as input\nbinding_scores = anchor2(p53_sequence, disorder_scores)\n\nprint(\"ANCHOR2 binding scores for first 10 residues:\")\nfor i, (aa, score) in enumerate(zip(p53_sequence[:10], binding_scores[:10])):\n    print(f\"  {i+1:3d} {aa}: {score:.3f}\")\n</code></pre>"},{"location":"tutorials/single_sequence/#aiupred-prediction","title":"AIUPred Prediction","text":"<p>AIUPred uses transformer-based deep learning for enhanced disorder prediction.</p> <p>Note</p> <p>Model weights (~82 MB) are automatically downloaded on first use.</p> <pre><code># Predict disorder using AIUPred\nai_disorder_scores = aiupred_disorder(p53_sequence, force_cpu=True)\n\nprint(\"AIUPred disorder scores for first 10 residues:\")\nfor i, (aa, score) in enumerate(zip(p53_sequence[:10], ai_disorder_scores[:10])):\n    print(f\"  {i+1:3d} {aa}: {score:.3f}\")\n</code></pre> <pre><code># Predict binding using AIUPred-binding\nai_binding_scores = aiupred_binding(p53_sequence, force_cpu=True)\n\nprint(\"AIUPred binding scores for first 10 residues:\")\nfor i, (aa, score) in enumerate(zip(p53_sequence[:10], ai_binding_scores[:10])):\n    print(f\"  {i+1:3d} {aa}: {score:.3f}\")\n</code></pre>"},{"location":"tutorials/single_sequence/#visualizing-results","title":"Visualizing Results","text":"<p>Here's how to plot the disorder predictions:</p> <pre><code>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)\n\npositions = range(1, len(p53_sequence) + 1)\n\n# Disorder predictions\naxes[0].plot(positions, disorder_scores, label='IUPred2', alpha=0.8)\naxes[0].plot(positions, ai_disorder_scores, label='AIUPred', alpha=0.8)\naxes[0].axhline(y=0.5, color='gray', linestyle='--', label='Threshold')\naxes[0].set_ylabel('Disorder Score')\naxes[0].set_title('Disorder Prediction for Human p53')\naxes[0].legend()\naxes[0].set_ylim(0, 1)\n\n# Binding predictions\naxes[1].plot(positions, binding_scores, label='ANCHOR2', alpha=0.8)\naxes[1].plot(positions, ai_binding_scores, label='AIUPred-binding', alpha=0.8)\naxes[1].axhline(y=0.5, color='gray', linestyle='--', label='Threshold')\naxes[1].set_xlabel('Residue Position')\naxes[1].set_ylabel('Binding Score')\naxes[1].set_title('Binding Region Prediction for Human p53')\naxes[1].legend()\naxes[1].set_ylim(0, 1)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"tutorials/single_sequence/#interpreting-results","title":"Interpreting Results","text":"<ul> <li>Scores &gt; 0.5 indicate predicted disordered or binding regions</li> <li>The N-terminus (residues 1-100) shows high disorder - this is the transactivation domain</li> <li>The DNA-binding domain (residues ~100-290) shows lower disorder scores</li> <li>The C-terminus shows high disorder - this is the regulatory domain</li> </ul> <p>Both IUPred2 and AIUPred capture these known structural features of p53.</p>"}]}